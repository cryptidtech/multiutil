use thiserror::Error;

/// Errors generated by the numeric type impls
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum Error {
    /// Multitrait decode error
    #[error(transparent)]
    Multtrait(#[from] multitrait::Error),

    /// Multicodec decode error
    #[error(transparent)]
    Multcodec(#[from] multicodec::Error),

    /// BaseEncoded error
    #[error(transparent)]
    BaseEncoded(#[from] BaseEncodedError),

    /// Tagged error
    #[error(transparent)]
    Tagged(#[from] TaggedError),
}

/// Errors generated by the base encoding smart pointer
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum BaseEncodedError {
    /// Multibase decode error
    #[error(transparent)]
    Multibase(#[from] multibase::Error),

    /// Value decoding failed
    #[error("Failed to decode the tagged value")]
    ValueFailed,
}

/// Errors generated by the tagged smart pointer
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum TaggedError {
    /// Sigil decoding failed
    #[error("Failed to decode the sigil")]
    SigilFailed,

    /// Incorrect multicodec sigil
    #[error("Expected {expected:?} sigil but received {received:?} sigil")]
    IncorrectSigil {
        /// The expected codec
        expected: multicodec::prelude::Codec,
        /// The codec deserialized
        received: multicodec::prelude::Codec,
    },

    /// Value decoding failed
    #[error("Failed to decode the tagged value")]
    ValueFailed,

    /// Custom error
    #[error("TaggegError::custom {0}")]
    Custom(String),
}

impl TaggedError {
    /// Build a custom error from a
    pub fn custom<T>(msg: T) -> Self
    where
        T: core::fmt::Display,
    {
        TaggedError::Custom(msg.to_string())
    }
}
